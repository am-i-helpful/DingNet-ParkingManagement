<!DOCTYPE html><html>  <head>    <meta content="text/html; charset=windows-1252" http-equiv="content-type">    <title>A Self-Adaptive Internet-of-Things Exemplar</title>  </head>  <body>    <h1>DingNet: A Self-Adaptive Internet-of-Things Exemplar</h1>    <h2>Installation</h2>    <p>To install the exemplar with the simulator,&nbsp; unzip the archive in      your preferred folder. This should create a folder with the name DingNet,      consisting of several subfolders with the source code of the DingNet      simualator, a javadoc, and a folder DingNetExe that contains a jar file of      the simulator and other supporting files (the zip archive of the      executable DingNetExe.zip contains only a jar file of the simulator and      other supporting files).&nbsp; You can run the simulator by either double      clicking the jar file or by opening a terminal, go to the DingNetExe      folder, and execute the command "java -jar DingNet.jar" </p>    <p>In this text we use the notation [knob] to refer to knobs and "section"      to refer to a text or selection in the GUI of the simulator. </p>    <h2>Test Installation</h2>    <p>You can perform a simple test of the simulator as follows: </p>    <p>- Configuration -&gt; click [Open] -&gt; select "testConfig.xml" and      click "Ok" (if necessary, center the map by clicking and and moving to see      the complete path of the mote) </p>    <p>- Input Profile -&gt; select ReliableEfficient by clicking the circle      next to the profile </p>    <p>- Simulation -&gt; click [Single Run] </p>    <p>The simulator should now show how the mote moves along its path. After      the run, you can see the results as follows: </p>    <p>- Select the button "Mote" (just above "Received power"), select "Mote 1"      and click "Ok"</p>    <p>- You can now select graphs with results for different system      characteristics, i.e., "Received power" that shows the power of the signal      received by the gateway that is located closest to the moving mote; "Power      Setting"that shows the power setting of the mote over the trajectory;      "Distance To Gateway" shows the actual distance of the moving mote to the      different gateways that receive its signals; and "Spreading Factor" that      shows the evolution of the spreading factor of the mote over the      trajectory. </p>    <p>- You can also select graphs with results of the sensor sampling, i.e.,      "Particular Matter," "Carbon Dioxide," "Soot," and "Ozone." For this      simple example, only samples for the first two parameters are taken. </p>    <p>The folder user/configurations shows the basic environment in xml      format (along with other configurations). The user/output folder contains      the output of a simulation run in xml format. The content of the folder      with the results can be cleared via the simulator GUI: "Experimental      Results" -&gt; click [Clear]. </p>    <h2>Configure Scenario</h2>    <p>The simulator allows a user to define configurations. There are two basic      options. In the first option, the user starts from a basic environment      and extend this environment with new elements. The environment can be      done via the simulator GUI, but it is limited to the predefined elements      (region and support for defining paths, types of motes, types of sensors).      The aim of the first option is mainly to perform rather small increments      of the starting environment. In the second option, the user can define      new elements to specify new configurations and smart city applications.      This option requires the user to define new classes for different elements      (instantiating abstract basic classes or further refine existing      classes.&nbsp;We illustrate a small example showing the first option. </p>    - Configuration -&gt; click [Open] -&gt; select "testConfig.xml" and click    "Ok" <br>    <br>    - Configuration -&gt; click [Configure] -&gt; click [Region]. This shows a    window of the region that we consider in this environment. The region is    divided in zones (6x6 in this case). Each zone is marked with a colored    circle that indicates a characteristic of the environment ("Forest," "City"    meaning an area with buildings, and "Plain" meaning an area with open    space). These characteristics affect the properties of signal transmissions    in the respective zones. The user can adapt the characteristic of a zone by    clicking the colored circle. E.g., click one of the circles of one of the    zones and select a different characteristic, then click "Ok." The change    will be immediately visible on the map. <br>    <br>    - Configuration -&gt; click [Configure] -&gt; click [] select "Gateway" This    opens the map with the gateways defined for the environment. By clicking    on one of the gateways, the user can see the settings of the different    elements of that gateway. Default, the settings of the predefined gateways    are not changeable. However, a user can add a gateway by clicking a location    on the map. This will open a new window that allows to configure the    parameters of the new gateway. Click "Save" once the gateway is properly    configured. <br>    <br>    - Configuration -&gt; click [Configure] -&gt; click [Mote]. This shows the    map with the motes.&nbsp; By clicking on a mote, a window opens that allow    to configure the mote. The user can set the coordinates, the initial setting    of the transmission power, the spreading factor, the sample rate, and the    moving speed. Furthermore, different sensors can be selected and added to    the mote. By clicking on a location on the map the user can add a new mote.    Click on the crossing of the paths marked with "N251" on the map, just above    the word "Heverlee." The&nbsp; window that opens allows the user to    configure the parameters of the new mote. Set the power setting to 10, the    spreading factor to 12, the sampling rate to 20 m and the movement speed to    1 m/s. Finally add a set of sensors. After the mote is properly defined,    click "Save" to add the mote to the environment. <br>    <br>    - Configuration -&gt; click [Configure] -&gt; click [Paths]. This opens the    map, where paths can be added. If you have added a new mote ("Mote 2")&nbsp;    in the previous step, a path for this mote can now be defined. You can use    either [Guided] or [Free]. With guided a path can be defined using    predefined waypoints. With free, a random path can be defined. Click    [Guided] and now click on the mote 2. Then select the first waypoint in the    direction of mote 1, click the next waypoint in that direction. Then click    waypoints in the direction north-west and follow the path until the    waypoints end (just after "Koning Boudewijnlaan").&nbsp; Then click [Save],    which saves the path for mote 2. <br>    <br>    - Configuration -&gt; click [Configure] -&gt; click [Close] ends configuring    the environment. Mote 2 and its path should now be visible on the    map.&nbsp;&nbsp; <br>    <br>    - Adaptation Goals. The simulator comes with three predefined adaptation    goals. "Reliable communication" defines the minimum and maximum bounds (in    dB) of the signal received at any of the gateways sent by a mote. "Energy    consumption" defines the maximum energy a mote is allowed to consume per    minute when it is actively sensing and sending the data to the gateways.    "Collision bound" defines the bound on the percentage of messages that get    lost due to collisions. By clicking [Edit], the values of the adaptation    goals can be changed.&nbsp; <br>    <br>    - Input Profile -&gt; click the "page &amp; paper" symbol next to    "ReliableEfficient" This opens a window that can be used to define the    parameters of the input profile. ReliableEfficient You can select the    required number of rounds for the scenerio and set the activity probability    of the motes, i.e., the probability that that mote will move along its path    in each round. To activate an input profile, select the circle left to the    name of the profile.<br>    <h2>Set up an Experiment with Self-Adaptation </h2>    <p>The main objective of the simulator is to support researchers in      evaluating their self-adaptation approaches. To that end, the user can add      a feedback loop system to the smart city application that is defined by a      environment. We illustrate now how self-adaptation can be realized using      a simple feedback loop system that comes with the simulator. </p>    <p>The main steps to evaluate a self-adaptation approach are: (1) define the      adaptation goals; (2) define the required probe and effector: and (3)      realize the feedback loop and connect it with the smart city application.      We explain now how each of these steps is supported. </p>    <p><b>Define Self-Adaptation Goals<br>      </b></p>    <p> </p>    <p>DingNet comes with two predefined types of adaptation goals: interval      adaptation goal and threshold adaptation goal. An interval adaptation goal      defines two values that determine the bounds on the values of a system      property.&nbsp; A threshold adaptation goal defines a single value that      should not be exceeded (above or below) of a system property of interest.      We illustrate both. </p>    <p>An interval adaptation goal is defined as follows: </p>    <p>public class IntervalAdaptationGoal extends AdaptationGoal {<br>      &nbsp;&nbsp;&nbsp; ...<br>      &nbsp;&nbsp;&nbsp; /**<br>      &nbsp;&nbsp;&nbsp;&nbsp; * Constructs a IntervalAdaptationGoal with a      given lower and upper value.<br>      &nbsp;&nbsp;&nbsp;&nbsp; * @param lowerBoundary The lower boundary of the      goal.<br>      &nbsp;&nbsp;&nbsp;&nbsp; * @param upperBoundary The upper boundary of the      goal.<br>      &nbsp;&nbsp;&nbsp;&nbsp; */<br>      &nbsp;&nbsp;&nbsp; public IntervalAdaptationGoal(Double lowerBoundary,      Double upperBoundary){<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.lowerBoundary =      lowerBoundary;<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.upperBoundary =      upperBoundary;<br>      &nbsp;&nbsp;&nbsp; }<br>      &nbsp;&nbsp;&nbsp; ...<br>      }</p>    A threshold adaptation goal is defined as follows:<br>    <br>    public class ThresholdAdaptationGoal extends AdaptationGoal {<br>    &nbsp;&nbsp;&nbsp; ...<br>    &nbsp;&nbsp;&nbsp; /**<br>    &nbsp;&nbsp;&nbsp;&nbsp; * A constructor generating a    ThresholdAdaptationGoal with given threshold.<br>    &nbsp;&nbsp;&nbsp;&nbsp; * @param threshold<br>    &nbsp;&nbsp;&nbsp;&nbsp; */<br>    &nbsp;&nbsp;&nbsp; public ThresholdAdaptationGoal(Double threshold){<br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.threshold = threshold;<br>    &nbsp;&nbsp;&nbsp; }<br>    &nbsp;&nbsp;&nbsp; ...<br>    }<br>    <br>    Other types of adaptation goals can be easily defined and added to DingNet.    <br>    <b><b><br>        Define Probe and Effector<br>      </b> </b>    <p> </p>    <p>DingNet comes with a predefined probe and effector that can be used to      monitor the behavior of the motes of the system and adapt their settings.      The probe is defined as follows: </p>    <p>public class MoteProbe {</p>    &nbsp;&nbsp;&nbsp;&nbsp; /** <br>    &nbsp;&nbsp;&nbsp;&nbsp; * Constructs a MoteProbe with no feedback loop    connected yet.&nbsp; <br>    &nbsp;&nbsp;&nbsp;&nbsp; */<br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public MoteProbe(){<br>    &nbsp;&nbsp;&nbsp;&nbsp; }&nbsp; <br>    <br>    &nbsp;&nbsp;&nbsp; /**<br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Connects the probe with a feedback loop.<br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * @param genericFeedbackLoop The given    feedback loop to be connected.<br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void    setGenericFeedbackLoop(GenericFeedbackLoop feedbackLoop){<br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    this.setGenericFeedbackLoop(feedbackLoop);<br>    &nbsp;&nbsp;&nbsp;&nbsp; }<br>    <br>    &nbsp; &nbsp;&nbsp; /**<br>    &nbsp;&nbsp;&nbsp;&nbsp; * Triggers the probe when new data of a mote with a    given EUI is received by a gateway. <br>    &nbsp;&nbsp;&nbsp;&nbsp; */ &nbsp;&nbsp;&nbsp;&nbsp; public void    trigger(Gateway gateway, Long moteDevEUI){<br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...<br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    getGenericFeedbackLoop().adapt(mote, gateway);<br>    &nbsp;&nbsp; &nbsp; }    <p>&nbsp;&nbsp;&nbsp;&nbsp; /**<br>      &nbsp;&nbsp;&nbsp;&nbsp; * Returns the power setting of a specific mote.<br>      &nbsp;&nbsp;&nbsp;&nbsp; * @param mote The mote to get the power setting      of.<br>      &nbsp;&nbsp;&nbsp;&nbsp; * @return the power setting of the mote.<br>      &nbsp;&nbsp;&nbsp;&nbsp; */<br>      &nbsp;&nbsp;&nbsp; public Integer getPowerSetting(NetworkEntity mote) {<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ... <br>      &nbsp;&nbsp;&nbsp; }<br>      <br>      &nbsp;&nbsp;&nbsp; /**<br>      &nbsp;&nbsp;&nbsp;&nbsp; * Returns the spreading factor of a given mote.<br>      &nbsp;&nbsp;&nbsp;&nbsp; * @param mote The mote to generate the graph of.<br>      &nbsp;&nbsp;&nbsp;&nbsp; * @return the spreading factor of the mote<br>      &nbsp;&nbsp;&nbsp;&nbsp; */<br>      &nbsp;&nbsp;&nbsp; public Integer getSpreadingFactor(NetworkEntity mote) {<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...<br>      &nbsp;&nbsp;&nbsp; }</p>    <p>&nbsp;&nbsp;&nbsp; /**<br>      &nbsp;&nbsp;&nbsp;&nbsp; * Returns the highest received signal by any of      the gateways for a given mote .<br>      &nbsp;&nbsp;&nbsp;&nbsp; * @param mote The mote to generate the graph of.<br>      &nbsp;&nbsp;&nbsp;&nbsp; * @return The highest received signal<br>      &nbsp;&nbsp;&nbsp;&nbsp; */<br>      &nbsp;&nbsp;&nbsp; public Double getHighestReceivedSignal(Mote mote) {<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...<br>      &nbsp;&nbsp;&nbsp; }</p>    <p>&nbsp;&nbsp;&nbsp; /**<br>      &nbsp;&nbsp;&nbsp;&nbsp; * Returns the distance to the nearest gateway.<br>      &nbsp;&nbsp;&nbsp;&nbsp; * @param mote the given mote to find the shortest      distance <br>      &nbsp;&nbsp;&nbsp;&nbsp; * @return The distance to the nearest Gateway.<br>      &nbsp;&nbsp;&nbsp;&nbsp; */<br>      &nbsp;&nbsp;&nbsp; public Double getShortestDistanceToGateway(Mote mote) {<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ... <br>      &nbsp;&nbsp;&nbsp; }<br>      }</p>    <p>The effector is defined as follows: </p>    <p>public class MoteEffector {</p>    &nbsp;&nbsp;&nbsp; ...<br>    &nbsp;&nbsp;&nbsp;/**<br>    &nbsp;&nbsp;&nbsp;&nbsp;* Constructs a MoteEffector .<br>    &nbsp;&nbsp;&nbsp;&nbsp;*/<br>    &nbsp;&nbsp;&nbsp;public MoteEffector(){<br>    &nbsp;&nbsp;&nbsp;}<br>    &nbsp;&nbsp;&nbsp; ...<br>    <p> &nbsp;&nbsp;&nbsp; /**<br>      &nbsp;&nbsp;&nbsp;&nbsp; * A method to set the power of a mote.<br>      &nbsp;&nbsp;&nbsp;&nbsp; * @param mote The mote to set the power of.<br>      &nbsp;&nbsp;&nbsp;&nbsp; * @param power The power to set.<br>      &nbsp;&nbsp;&nbsp;&nbsp; */<br>      &nbsp;&nbsp;&nbsp; public void setPower(Mote mote, Integer power){<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      mote.setTransmissionPower(power);<br>      &nbsp;&nbsp;&nbsp; }<br>      <br>      &nbsp;&nbsp;&nbsp; /**<br>      &nbsp;&nbsp;&nbsp;&nbsp; * A method to set the spreading factor of a mote.<br>      &nbsp;&nbsp;&nbsp;&nbsp; * @param mote The mote to set the spreading      factor of.<br>      &nbsp;&nbsp;&nbsp;&nbsp; * @param spreadingFactor The spreading factor to      set.<br>      &nbsp;&nbsp;&nbsp;&nbsp; */<br>      &nbsp;&nbsp;&nbsp; public void setSpreadingFactor(Mote mote, Integer      spreadingFactor){<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mote.setSF(spreadingFactor);<br>      &nbsp;&nbsp;&nbsp; }<br>      <br>      &nbsp;&nbsp;&nbsp; /**<br>      &nbsp;&nbsp;&nbsp;&nbsp; * A method to set the sampling rate of a mote.<br>      &nbsp;&nbsp;&nbsp;&nbsp; * @param mote The mote to set the sampling rate      of.<br>      &nbsp;&nbsp;&nbsp;&nbsp; * @param samplingRate The sampling rate to set.<br>      &nbsp;&nbsp;&nbsp;&nbsp; */<br>      &nbsp;&nbsp;&nbsp; public void setSamplingRate(Mote mote, Integer      samplingRate){<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      mote.setSamplingRate(samplingRate);<br>      &nbsp;&nbsp;&nbsp; }<br>      <br>      &nbsp;&nbsp;&nbsp; /**<br>      &nbsp;&nbsp;&nbsp;&nbsp; * A method to set the movement speed of a mote.<br>      &nbsp;&nbsp;&nbsp;&nbsp; * @param mote The mote to set the movement speed      of.<br>      &nbsp;&nbsp;&nbsp;&nbsp; * @param movementSpeed The movement speed to set.<br>      &nbsp;&nbsp;&nbsp;&nbsp; */<br>      &nbsp;&nbsp;&nbsp; public void setMovementSpeed(Mote mote, Double      movementSpeed){<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      mote.setMovementSpeed(movementSpeed);<br>      &nbsp;&nbsp;&nbsp; }<br>      }</p>    <p>De user can add new probes and effectors, at the level of motes,      gateways, and applications, as needed.</p>    <p><b><b>Realize Feedback Loop and Connect with the System <br>        </b> </b> </p>    <p> </p>    <p>Finally, we have to realize a feedback loop and connect it to the system      via probes and effectors. We illustrate this for an adaptation approach      that adapts the power setting of motes to ensure reliable communication.      This simple adaptation example comes with the DingNet exemplar. </p>    <p>The last step consists of four parts: (1) encode the feedback loop, (2)      instantiate the adaptation goals, (2) instantiate the probe and      effector,&nbsp; and (4) instantiate the feedback loop and connect it with      the system.&nbsp; </p>    <p>For the example, the feedback loop is defined as follows: </p>    <p>/**<br>      &nbsp;* A class representing the feedback loop of a simple signal based      adaptation approach.<br>      &nbsp;*/<br>      public class ReliableEfficientSignalGateway extends GenericFeedbackLoop {<br>      &nbsp;&nbsp;&nbsp; /**<br>      &nbsp;&nbsp;&nbsp;&nbsp; * Constructs a new instance of the signal based      adaptation approach with a given upper and lower value for the signal.<br>      &nbsp;&nbsp;&nbsp;&nbsp; * @param adaptationGoal The adaptation goal for      the received signal strength.<br>      &nbsp;&nbsp;&nbsp;&nbsp; */<br>      &nbsp;&nbsp;&nbsp; public      ReliableEfficientSignalGateway(IntervalAdaptationGoal adaptationGoal){<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.adaptationGoal =      adaptationGoal;<br>      &nbsp;&nbsp;&nbsp; }</p>    &nbsp;&nbsp;&nbsp; ...    <p>&nbsp;&nbsp;&nbsp; @Override<br>      &nbsp;&nbsp;&nbsp; public void adapt(Mote mote, Gateway) {<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /**<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * If the average of      strength of five received signals is above the upper bound, the      transmitting power is decreased by 1;<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      */<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      if (average &gt; getUpperBound()) {<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      if (getMoteProbe().getPowerSetting(mote) &gt; -3) {<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      getMoteEffector().setPower(mote, getMoteProbe().getPowerSetting(mote) -      1);<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      }<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      }<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      /**<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      * If the average of strength of five received signals is below the lower      bound, the transmitting power is increased by 1;<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      */<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      if (average &lt; getLowerBound()) {<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      if (getMoteProbe().getPowerSetting(mote) &lt; 14) {<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      getMoteEffector().setPower(mote, getMoteProbe().getPowerSetting(mote) +      1);<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      }<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      }<br>      <br>      &nbsp;&nbsp;&nbsp; ...<br>      &nbsp; }</p>    We instantiate an interval adaptation goal as follows: <br>    <p> Double lowerBoundary = 48; <br>      Double upperBoundary = 43; <br>      IntervalAdaptationGoal intervalAdaptationGoal = new      IntervalAdaptationGoal(lowerBoundary, upperBoundary); </p>    <p>We instantiate the predefined probe and effector of DingNet: </p>    MoteProbe moteProbe = new MoteProbe();<br>    MoteEffector moteEffector = new MoteEffector(); <br>    <p>Finally we instantiate the feedback loop and connect it with the system      as follows: </p>    ReliableEfficientSignalGateway feedbackLoop = new    ReliableEfficientSignalGateway(intervalAdaptationGoal);<br>    feedbackLoop.addProbe(moteProbe);&nbsp;<br>    feedbackLoop.addEffector(moteEffector);&nbsp; <br>    feedbackLoop.start();&nbsp;<br>    <h2>Experimentation with Self-Adaptation </h2>    <p>Finally, the simulator can be used to perform experiments with the      self-adaptation approach. After the environment and the adaptation      approach are specified as explained above, the user can either perform a      single run or a series of runs.&nbsp;</p>    <p><b><b> Single Run<br>        </b> </b> </p>    <p> </p>    <p>- Simulation -&gt; click [Single Run] This performs a single run of the      specified scenario; the moving motes that be observed on the map. The      speed of a run can be changed using the "Speed" slider. </p>    <p>- To inspect the results of system parameters, click [Mote] above the      area for the graphs on the right side. Different system parameters for the      selected mote can be inspected as explained above. </p>    <p>- To inspect the results of the domain (sensor readings), click [Mote] or      [Region] above the area for the graphs on the left side. Different sensor      readings for the selected mote or region can be inspected as explained      above. </p>    <p><b><b>Total Run<br>        </b> </b> </p>    <p> </p>    <p> - Simulation -&gt; click [Total Run] This performs a number of run of      the specified scenario as defined in the input profile. The movements of      the motes for the option total run are not shown. </p>    <p>- To inspect the simulation results, click [Mote] or [Region] above the      graph areas and select a mote with a run or a region and run. The graphs      with the results can then be inspected.</p>    <p>      - Experimental results -&gt; click [Save] opens a window that allows a      user to save all results of a simulation in xml format. This allows to      compare different adaptation approaches for different scenarios. By      clicking [Clear] the buffer with the simulation results can be      cleared.&nbsp; </p>    <p><br>    </p>    <b><br>      <br>      <br>      <br>    </b>  </body></html>