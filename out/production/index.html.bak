<!DOCTYPE html><html>  <head>    <meta content="text/html; charset=windows-1252" http-equiv="content-type">    <title>DingNet:A dynamic LoraWan simulator</title>  </head>  <body>    <h1>DingNet: A Self-Adaptive Internet-of-Things Exemplar</h1>    <h2>Installation</h2>    <p>To install the exemplar with the simulator,&nbsp; unzip the archive in      your preferred folder. This should create a folder with the name      LoraSimDynamic, consisting of several subfolders with the source code of      the DingNet simualator, a javadoc, and a folder DingNet that contains a      jar file of the simulator and other supporting files.&nbsp; You can run      the simulator by either double clicking the jar file or by opening a      terminal, to to the DingNet folder, and execute the command "java -jar      LoraSimDynamic.jar" In this text we use the notation [knob] to refer to      knobs and "section" to refer to a selection in the GUI of the simulator. </p>    <h2>Test Installation</h2>    <p>You can perform a simple test of the simulator as follows: </p>    <p>- Configuration -&gt; click [Open] -&gt; select "testConfig.xml" and      click "Ok" (if necessary, center the map by clicking and and moving to see      the complete path of the mote) </p>    <p>- Input Profile -&gt; select ReliableEfficient by clicking the circle      next to the profile </p>    <p>- Simulation -&gt; click [Single Run] </p>    <p>The simulator should now show how the mote moves along its path. After      the run, you can see the results as follows: </p>    <p>- Select the button "Mote" (just above "Received power"), select "Mote 1"      and click "Ok"</p>    <p>- You can now select graphs with results for different system      characteristics, i.e., "Received power" that shows the power of the signal      received by the gateway that is located closest to the moving mote; "Power      Setting"that shows the power setting of the mote over the trajectory;      "Distance To Gateway" shows the actual distance of the moving mote to the      different gateways that receive its signals; and "Spreading Factor" that      shows the evolution of the spreading factor of the mote over the      trajectory. </p>    <p>- You can also select graphs with results of the sensor sampling, i.e.,      "Particular Matter," "Carbon Dioxide," "Soot," and "Ozone." For this      simple example, only samples for the first two parameters are taken. </p>    <p>The folder user/configurations shows the basic configuration in xml      format (along with other configurations). The user/output folder contains      the output of a simulation run in xml format. The content of the folder      with the results can be cleared via the simulator GUI: "Experimental      Results" -&gt; click [Clear]. </p>    <h2>Configure Scenario</h2>    <p>The simulator allows a user to define configurations. There are two basic      options. In the first option, the user starts from a basic configuration      and extend this configuration with new elements. The configuration can be      done via the simulator interface, but it is limited to the predefined      elements (region and support for defining paths, types of motes, types of      sensors). The aim of the first option is mainly to perform small      increments of the starting configuration. In the second option, the user      can define new elements to specify new types of configurations and smart      city applications. This option requires the user to define new classes for      different elements (instantiating abstract basic classes or further refine      existing classes.&nbsp;We illustrate a small example showing the first      option. </p>    - Configuration -&gt; click [Open] -&gt; select "testConfig.xml" and click    "Ok" <br>    <br>    - Configuration -&gt; click [Configure] -&gt; select "Region" This shows a    window of the region that we consider in this configuration. The region is    divided in zones (6x6 in this case). Each zone is marked with a colored    circle that indicates a characteristic of the environment ("Forest," "City"    meaning an area with buildings, and "Plain" meaning an area with open    space). These characteristics affect the properties of signal transmissions    in the respective zones. The user can adapt the characteristic of a zone by    clicking the colored circle. E.g., click one of the circles of one of the    zones and select a different characteristic, then click "Ok." The change    will be immediately visible on the map. <br>    <br>    - Configuration -&gt; click [Configure] -&gt; select "Gateway" This opens    the map with the gateways defined for the configuration. By clicking on one    of the gateways, the user can see the settings of the different elements of    that gateway. Default, the settings of the predefined gateways are not    changeable. However, a user can add a gateway by clicking a location on the    map. This will open a new window that allows to configure the parameters of    the new gateway. Click "Save" once the gateway is properly configured. <br>    <br>    - Configuration -&gt; click [Configure] -&gt; select "Mote" This shows the    map with the motes.&nbsp; By clicking on a mote, a window opens that allow    to configure the mote. The user can set the coordinates, the initial setting    of the transmission power, the spreading factor, the sample rate, and the    moving speed. Furthermore, different sensors can be selected and added to    the mote. By clicking on a location on the map the user can add a new mote.    Click on the crossing of the paths just above the word "Heverlee." The&nbsp;    window that opens allows the user to configure the parameters of the new    mote. Set the power setting to 10, the spreading factor to 12, the sampling    rate to 20 m and the movement speed to 0.5 m/s. Finally add a set of    sensors. After the mote is properly defined, click "Save" to add the mote to    the configuration. <br>    <br>    - Configuration -&gt; click [Configure] -&gt; select "Paths" This opens the    map&nbsp; where paths can be added. If you have added a new mote ("Mote    2")&nbsp; in the previous step, a path for this mote can now be defined. You    can use either [Guided] or [Free]. With guided a path can be defined using    predefined waypoints. With free, a random path can be defined. Click    [Guided] and now click on the mote 2. Then select the first waypoint in the    direction of mote 1, click the next waypoint in that direction. Then click    waypoints to the north and follow the path until the waypoints end (just    after "Koning Boudewijnlaan").&nbsp; Then click "Save" which safes the path    for mote 2. <br>    <br>    - Configuration -&gt; click [Configure] -&gt; select "Close" This ends    configuring the configuration.&nbsp; <br>    <br>    - Input Profile -&gt; click the page &amp; paper symbol next to    "ReliableEfficient" This window allows defining parameters of the input    profile. You can select the required number of rounds for the scnerio and    set the activity probability of the motes, i.e., the probability that that    mote will move along its path in each round. <br>    <h2>Experiment with Self-Adaptation </h2>    <p>The main objective of the simulator is to support researchers in      evaluating their self-adaptation approaches. To that end, the user can add      a feedback loop system to the smart city application that is defined by a      configuration. We illustrate now how self-adaptation can be realized using      a simple feedback loop system that comes with the simulator. </p>    <p>The key steps to evaluate a self-adaptation approach are: (1) define the      adaptation goals; (2) define the required probe and effector: and (3)      realize the feedback loop and connect it with the smart city application.      We explain now how each of these steps is supported. </p>    <p><b>Define Self-Adaptation Goals<br>      </b></p>    <p> </p>    <p>DingNet comes with two predefined types of adaptation goals: interval      adaptation goal and threshold adaptation goal. An interval adaptation goal      defines two values that determine the bounds on the values of a system      property.&nbsp; A threshold adaptation goal defines a single value that      should not be exceeded (above or below) of a system property of interest.      We illustrate both. </p>    <p>An interval adaptation goal is defined as follows: </p>    <p>public class IntervalAdaptationGoal extends AdaptationGoal {<br>      &nbsp;&nbsp;&nbsp; ...<br>      &nbsp;&nbsp;&nbsp; /**<br>      &nbsp;&nbsp;&nbsp;&nbsp; * Constructs a IntervalAdaptationGoal with a      given lower and upper value.<br>      &nbsp;&nbsp;&nbsp;&nbsp; * @param lowerBoundary The lower boundary of the      goal.<br>      &nbsp;&nbsp;&nbsp;&nbsp; * @param upperBoundary The upper boundary of the      goal.<br>      &nbsp;&nbsp;&nbsp;&nbsp; */<br>      &nbsp;&nbsp;&nbsp; public IntervalAdaptationGoal(Double lowerBoundary,      Double upperBoundary){<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.lowerBoundary =      lowerBoundary;<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.upperBoundary =      upperBoundary;<br>      &nbsp;&nbsp;&nbsp; }<br>      &nbsp;&nbsp;&nbsp; ...<br>      }</p>    A threshold adaptation goal is defined as follows:<br>    <br>    public class ThresholdAdaptationGoal extends AdaptationGoal {<br>    &nbsp;&nbsp;&nbsp; ...<br>    &nbsp;&nbsp;&nbsp; /**<br>    &nbsp;&nbsp;&nbsp;&nbsp; * A constructor generating a    ThresholdAdaptationGoal with given threshold.<br>    &nbsp;&nbsp;&nbsp;&nbsp; * @param threshold<br>    &nbsp;&nbsp;&nbsp;&nbsp; */<br>    &nbsp;&nbsp;&nbsp; public ThresholdAdaptationGoal(Double threshold){<br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.threshold = threshold;<br>    &nbsp;&nbsp;&nbsp; }<br>    &nbsp;&nbsp;&nbsp; ...<br>    }<br>    <br>    Other types of adaptation goals can be easily defined and added to DingNet.    <br>    <b><b><br>        Define Probe and Effector<br>      </b> </b>    <p> </p>    <p>DingNet comes with a predefined probe and effector that can be used to      monitor the behavior of the motes of the system and adapt their settings.      The probe is defined as follows: </p>    <p>public class MoteProbe {</p>    &nbsp;&nbsp;&nbsp;&nbsp; /** <br>    &nbsp;&nbsp;&nbsp;&nbsp; * Constructs a MoteProbe with no feedback loop    connected yet.&nbsp; <br>    &nbsp;&nbsp;&nbsp;&nbsp; */<br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public MoteProbe(){<br>    &nbsp;&nbsp;&nbsp;&nbsp; }&nbsp; <br>    <br>    &nbsp;&nbsp;&nbsp; /**<br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Connects the probe with a feedback loop.<br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * @param genericFeedbackLoop The given    feedback loop to be connected.<br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void    addGenericFeedbackLoop(GenericFeedbackLoop feedbackLoop){<br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    this.feedbackLoop.connect(feedbackLoop);<br>    &nbsp;&nbsp;&nbsp;&nbsp; }<br>    <br>    &nbsp; &nbsp;&nbsp; /**<br>    &nbsp;&nbsp;&nbsp;&nbsp; * Triggers the mote providing new data of a mote    with a given EUI by a gateway . <br>    &nbsp;&nbsp;&nbsp;&nbsp; */ &nbsp;&nbsp;&nbsp;&nbsp; public void    trigger(Gateway gateway, Long moteDevEUI){<br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...<br>    &nbsp;&nbsp; &nbsp; }    <p>&nbsp;&nbsp;&nbsp;&nbsp; /**<br>      &nbsp;&nbsp;&nbsp;&nbsp; * Returns the power setting of a specific mote.<br>      &nbsp;&nbsp;&nbsp;&nbsp; * @param mote The mote to get the power setting      of.<br>      &nbsp;&nbsp;&nbsp;&nbsp; * @return the power setting of the mote.<br>      &nbsp;&nbsp;&nbsp;&nbsp; */<br>      &nbsp;&nbsp;&nbsp; public Integer getPowerSetting(NetworkEntity mote) {<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ... <br>      &nbsp;&nbsp;&nbsp; }<br>      <br>      &nbsp;&nbsp;&nbsp; /**<br>      &nbsp;&nbsp;&nbsp;&nbsp; * Returns the spreading factor of a given mote.<br>      &nbsp;&nbsp;&nbsp;&nbsp; * @param mote The mote to generate the graph of.<br>      &nbsp;&nbsp;&nbsp;&nbsp; * @return the spreading factor of the mote<br>      &nbsp;&nbsp;&nbsp;&nbsp; */<br>      &nbsp;&nbsp;&nbsp; public Integer getSpreadingFactor(NetworkEntity mote) {<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...<br>      &nbsp;&nbsp;&nbsp; }</p>    <p>&nbsp;&nbsp;&nbsp; /**<br>      &nbsp;&nbsp;&nbsp;&nbsp; * Returns the highest received signal by any of      the gateways for a given mote .<br>      &nbsp;&nbsp;&nbsp;&nbsp; * @param mote The mote to generate the graph of.<br>      &nbsp;&nbsp;&nbsp;&nbsp; * @return The highest received signal<br>      &nbsp;&nbsp;&nbsp;&nbsp; */<br>      &nbsp;&nbsp;&nbsp; public Double getHighestReceivedSignal(Mote mote) {<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...<br>      &nbsp;&nbsp;&nbsp; }</p>    <p>&nbsp;&nbsp;&nbsp; /**<br>      &nbsp;&nbsp;&nbsp;&nbsp; * Returns the distance to the nearest gateway.<br>      &nbsp;&nbsp;&nbsp;&nbsp; * @param mote the given mote to find the shortest      distance <br>      &nbsp;&nbsp;&nbsp;&nbsp; * @return The distance to the nearest Gateway.<br>      &nbsp;&nbsp;&nbsp;&nbsp; */<br>      &nbsp;&nbsp;&nbsp; public Double getShortestDistanceToGateway(Mote mote) {<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ... <br>      &nbsp;&nbsp;&nbsp; }<br>      }</p>    <p>The effector is defined as follows: </p>    <p>public class MoteEffector {</p>    <p>&nbsp;&nbsp;&nbsp; ...<br>    </p>    <p>&nbsp;&nbsp;&nbsp;/**<br>      &nbsp;&nbsp;&nbsp;&nbsp;* Constructs a MoteEffector .<br>      &nbsp;&nbsp;&nbsp;&nbsp;*/<br>      &nbsp;&nbsp;&nbsp;public MoteEffector(){<br>      &nbsp;&nbsp;&nbsp;}<br>      &nbsp;&nbsp;&nbsp; ...</p>    <p><br>      &nbsp;&nbsp;&nbsp; /**<br>      &nbsp;&nbsp;&nbsp;&nbsp; * A method to set the power of a mote.<br>      &nbsp;&nbsp;&nbsp;&nbsp; * @param mote The mote to set the power of.<br>      &nbsp;&nbsp;&nbsp;&nbsp; * @param power The power to set.<br>      &nbsp;&nbsp;&nbsp;&nbsp; */<br>      &nbsp;&nbsp;&nbsp; public void setPower(Mote mote, Integer power){<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      mote.setTransmissionPower(power);<br>      &nbsp;&nbsp;&nbsp; }<br>      <br>      &nbsp;&nbsp;&nbsp; /**<br>      &nbsp;&nbsp;&nbsp;&nbsp; * A method to set the spreading factor of a mote.<br>      &nbsp;&nbsp;&nbsp;&nbsp; * @param mote The mote to set the spreading      factor of.<br>      &nbsp;&nbsp;&nbsp;&nbsp; * @param spreadingFactor The spreading factor to      set.<br>      &nbsp;&nbsp;&nbsp;&nbsp; */<br>      &nbsp;&nbsp;&nbsp; public void setSpreadingFactor(Mote mote, Integer      spreadingFactor){<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mote.setSF(spreadingFactor);<br>      &nbsp;&nbsp;&nbsp; }<br>      <br>      &nbsp;&nbsp;&nbsp; /**<br>      &nbsp;&nbsp;&nbsp;&nbsp; * A method to set the sampling rate of a mote.<br>      &nbsp;&nbsp;&nbsp;&nbsp; * @param mote The mote to set the sampling rate      of.<br>      &nbsp;&nbsp;&nbsp;&nbsp; * @param samplingRate The sampling rate to set.<br>      &nbsp;&nbsp;&nbsp;&nbsp; */<br>      &nbsp;&nbsp;&nbsp; public void setSamplingRate(Mote mote, Integer      samplingRate){<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      mote.setSamplingRate(samplingRate);<br>      &nbsp;&nbsp;&nbsp; }<br>      <br>      &nbsp;&nbsp;&nbsp; /**<br>      &nbsp;&nbsp;&nbsp;&nbsp; * A method to set the movement speed of a mote.<br>      &nbsp;&nbsp;&nbsp;&nbsp; * @param mote The mote to set the movement speed      of.<br>      &nbsp;&nbsp;&nbsp;&nbsp; * @param movementSpeed The movement speed to set.<br>      &nbsp;&nbsp;&nbsp;&nbsp; */<br>      &nbsp;&nbsp;&nbsp; public void setMovementSpeed(Mote mote, Double      movementSpeed){<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      mote.setMovementSpeed(movementSpeed);<br>      &nbsp;&nbsp;&nbsp; }<br>      }</p>    <p>De user can add new probes and effectors, at the level of motes,      gateways, and applications, as needed.</p>    <p><b><b>Realize Feedback Loop and Connect with the System <br>        </b> </b> </p>    <p> </p>    <p>Finally, we have to realize the feedback loop that realizes the      self-adaptation and connect is to the system via probes and effectors. We      illustrate this for an adaptation approach that adapts the power setting      of motes to ensure reliable communication. This simple adaptation example      comes with the DingNet exemplar. </p>    <p>The last step consists of four parts: (1) encode the feedback loop, (2)      instantiate the adaptation goals, (2) instantiate the probe and      effector,&nbsp; and (4) instantiate the feedback loop and connect it with      the system.&nbsp; </p>    <p>For the example, the feedback loop is defined as follows: </p>    <p>/**<br>      &nbsp;* A class representing the feedback loop of a simple signal based      adaptation approach.<br>      &nbsp;*/<br>      public class ReliableEfficientSignalGateway extends GenericFeedbackLoop {<br>      &nbsp;&nbsp;&nbsp; /**<br>      &nbsp;&nbsp;&nbsp;&nbsp; * Constructs a new instance of the signal based      adaptation approach with a given upper and lower value for the signal.<br>      &nbsp;&nbsp;&nbsp;&nbsp; * @param adaptationGoal The adaptation goal for      the received signal strength.<br>      &nbsp;&nbsp;&nbsp;&nbsp; * @param probe The probe used by the feedback      loop.<br>      &nbsp;&nbsp;&nbsp;&nbsp; * @param effector The effector used by the      feedback loop.<br>      &nbsp;&nbsp;&nbsp;&nbsp; */<br>      &nbsp;&nbsp;&nbsp; public      ReliableEfficientSignalGateway(IntervalAdaptationGoal adaptationGoal){<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.adaptationGoal =      adaptationGoal;<br>      &nbsp;&nbsp;&nbsp; }</p>    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.probe =      moteProbe;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.effector = moteEffector; </p>    <p>&nbsp;&nbsp;&nbsp; ...</p>    <p>&nbsp;&nbsp;&nbsp; @Override<br>      &nbsp;&nbsp;&nbsp; public void adapt(Mote mote) {<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Double receivedSignal =      moteProbe.getHighestReceivedSignal(mote);<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      ReliableMinSignalBuffer.add(receivedSignal);<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if      (ReliableMinSignalBuffer.size() == 5) {<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double      average = 0;<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for      (Double signal : ReliableMinSignalBuffer) {<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      average += signal ;<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; average      = average / 5;<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if      (average &gt; adaptationGoal.getUpperBound()) {<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      if (moteProbe.getPowerSetting(mote) &gt; -3)<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      moteEffector.setPower(mote, moteProbe.getPowerSetting(mote) - 1);<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if      (average &lt; adaptationGoal.getLowerBound()) {<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      if (moteProbe.getPowerSetting(mote) &lt; 14)<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      moteEffector.setPower(mote, moteProbe.getPowerSetting(mote) + 1);<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      ReliableMinSignalBuffer = new LinkedList&lt;&gt;();<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>      &nbsp;&nbsp;&nbsp; }<br>      &nbsp;&nbsp;&nbsp; ...<br>      }</p>    We instantiate an interval adaptation goal as follows: <br>    <p> Double lowerBoundary = 48; <br>      Double upperBoundary = 43; <br>      IntervalAdaptationGoal intervalAdaptationGoal = new      IntervalAdaptationGoal(lowerBoundary, upperBoundary); </p>    <p>We instantiate the predefined probe and effector of DingNet: </p>    MoteProbe moteProbe = new MoteProbe();<br>    MoteEffector moteEffector = new MoteEffector(); <br>    <p>Finally we instantiate the feedback loop and connect it with the system      as follows: </p>    ReliableEfficientSignalGateway feedbackLoop = new    ReliableEfficientSignalGateway(intervalAdaptationGoal);<br>    feedbackLoop.addProbe(moteProbe);&nbsp;<br>    feedbackLoop.addEffector(moteEffector);&nbsp; <br>    feedbackLoop.start();&nbsp;<br>    <p><br>      <br>    </p>    <p><br>    </p>    <b><br>      <br>      <br>      <br>    </b>  </body></html>